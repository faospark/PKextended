using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Reflection;
using UnityEngine;
using PKCore.Models;
using BepInEx;
using Il2CppInterop.Runtime;

namespace PKCore.Utils;

/// <summary>
/// Discovers and logs existing map objects (both Unity visual and native EVENT_OBJ data)
/// to help users copy object configurations for modding.
/// </summary>
public static class ObjectDiscovery
{
    private static HashSet<string> _discoveredMaps = new HashSet<string>();
    private static Dictionary<string, List<DiscoveredObject>> _discoveredObjects = new Dictionary<string, List<DiscoveredObject>>();

    public static void DiscoverObjectsInScene(GameObject sceneRoot)
    {
        try
        {
            string mapId = sceneRoot.name.Replace("(Clone)", "");

            if (_discoveredMaps.Contains(mapId))
                return;

            Plugin.Log.LogInfo($"[ObjectDiscovery] Processing '{sceneRoot.name}' as MapID: '{mapId}'");
            Plugin.Log.LogInfo($"[ObjectDiscovery] Discovering objects in map: {mapId}");

            List<DiscoveredObject> objects = new List<DiscoveredObject>();

            // 1. Discover Unity visual objects from the "object" folder
            Transform objectFolder = FindObjectFolder(sceneRoot.transform);
            if (objectFolder != null)
            {
                // Scan all descendants recursively — objects are often grouped (Table → Table_Top, Table_Legs, etc.)
                DiscoverUnityObjectsRecursive(objectFolder, objects);
            }
            else
            {
                Plugin.Log.LogWarning($"[ObjectDiscovery] No 'object' folder found in {mapId}");
            }

            // 2. Discover native EVENT_OBJ entries from MAPEVDAT
            try
            {
                DiscoverNativeEventObjects(sceneRoot, objects);
            }
            catch (Exception ex)
            {
                Plugin.Log.LogWarning($"[ObjectDiscovery] Failed to read native event objects: {ex.Message}");
            }

            _discoveredObjects[mapId] = objects;
            _discoveredMaps.Add(mapId);

            Plugin.Log.LogInfo($"[ObjectDiscovery] Discovered {objects.Count} objects in {mapId}");

            SaveDiscoveredObjects();
        }
        catch (Exception ex)
        {
            Plugin.Log.LogError($"[ObjectDiscovery] Error discovering objects: {ex}");
        }
    }

    // ─── Unity Object Discovery ─────────────────────────────────────────────────

    private static void DiscoverUnityObjectsRecursive(Transform parent, List<DiscoveredObject> objects)
    {
        for (int i = 0; i < parent.childCount; i++)
        {
            Transform child = parent.GetChild(i);
            var discovered = DiscoverUnityObject(child.gameObject);
            if (discovered != null)
                objects.Add(discovered);

            // Recurse into children (e.g. Table → Table_Top, Table_Legs)
            if (child.childCount > 0)
                DiscoverUnityObjectsRecursive(child, objects);
        }
    }

    private static DiscoveredObject DiscoverUnityObject(GameObject obj)
    {
        try
        {
            var spriteRenderer = obj.GetComponent<SpriteRenderer>();
            bool hasSpriteRenderer = spriteRenderer != null;
            string textureName = spriteRenderer?.sprite?.texture?.name ?? "none";
            int sortingOrder = spriteRenderer?.sortingOrder ?? 0;

            bool hasCollision = false;
            string colliderType = null;
            bool isMovable = false;
            string rigidbodyType = null;
            bool isInteractable = false;
            string interactableType = null;
            string dialogText = null;

            var components = obj.GetComponents<Component>();
            foreach (var component in components)
            {
                if (component == null) continue;
                string typeName = component.GetType().Name;

                if (typeName.Contains("Collider"))
                {
                    hasCollision = true;
                    colliderType ??= typeName;
                }

                if (typeName.Contains("Rigidbody"))
                {
                    isMovable = true;
                    rigidbodyType ??= typeName;
                }

                if (typeName.Contains("Interact", StringComparison.OrdinalIgnoreCase) ||
                    typeName.Contains("Event", StringComparison.OrdinalIgnoreCase) ||
                    typeName.Contains("Action", StringComparison.OrdinalIgnoreCase) ||
                    typeName.Contains("Trigger", StringComparison.OrdinalIgnoreCase))
                {
                    isInteractable = true;
                    interactableType ??= typeName;
                }

                if (dialogText == null)
                    dialogText = TryExtractDialogText(component);
            }

            return new DiscoveredObject
            {
                Name = obj.name,
                Texture = textureName,
                HasSpriteRenderer = hasSpriteRenderer,
                Position = new Vector3Config
                {
                    X = obj.transform.localPosition.x,
                    Y = obj.transform.localPosition.y,
                    Z = obj.transform.localPosition.z
                },
                Scale = new Vector3Config
                {
                    X = obj.transform.localScale.x,
                    Y = obj.transform.localScale.y,
                    Z = obj.transform.localScale.z
                },
                Rotation = obj.transform.localEulerAngles.z,
                SortingOrder = sortingOrder,
                Active = obj.activeSelf,
                HasCollision = hasCollision,
                ColliderType = colliderType,
                IsMovable = isMovable,
                RigidbodyType = rigidbodyType,
                IsInteractable = isInteractable,
                InteractableType = interactableType,
                DialogText = dialogText,
            };
        }
        catch (Exception ex)
        {
            Plugin.Log.LogWarning($"[ObjectDiscovery] Error discovering object {obj.name}: {ex.Message}");
            return null;
        }
    }

    // ─── Native EVENT_OBJ Discovery via MAPEVDAT ────────────────────────────────

    private static void DiscoverNativeEventObjects(GameObject sceneRoot, List<DiscoveredObject> objects)
    {
        var machi = PKCore.Patches.MachiLoader_Load_Patch.LastLoadedMachiDat;
        if (machi == null)
        {
            Plugin.Log.LogWarning($"[ObjectDiscovery] No MACHIDAT cached yet. Native object discovery skipped.");
            return;
        }

        var mdat = machi;
        if (mdat.eventdata == null || mdat.eventdata.mapeventdat == null)
        {
            Plugin.Log.LogWarning($"[ObjectDiscovery] Cached MACHIDAT has no valid EVENTDAT.");
            return;
        }

        var mapEvents = mdat.eventdata.mapeventdat;
        int totalEventCount = 0;

        foreach (var mapData in mapEvents)
        {
            var eventObjs = mapData.eventobj;
            if (eventObjs == null) continue;

            for (int i = 0; i < eventObjs.Length; i++)
            {
                EVENT_OBJ e = eventObjs[i];
                if (e == null) continue;

                string label = GetObjectTypeLabel(e.otyp);

                objects.Add(new DiscoveredObject
                {
                    Name = $"Native_ev{totalEventCount:D3}_{label}",
                    NativeIndex = totalEventCount,
                    ObjectType = e.otyp,
                    Disp = e.disp,
                    Speed = e.spd,
                    WalkType = e.wt,
                    AnimationNo = e.ano,
                    InteractType = e.ityp,
                    FaceNo = e.fpno,
                    RenderGroup = e.ozok,
                    Priority = e.pri,
                    NativeX = e.x,
                    NativeY = e.y,
                    NativeW = e.w,
                    NativeH = e.h,
                    // Mark as native (no Unity position or texture)
                    Position = new Vector3Config { X = e.x, Y = e.y, Z = 0 },
                    IsInteractable = e.ityp > 0,
                });

                totalEventCount++;
            }
        }

        Plugin.Log.LogInfo($"[ObjectDiscovery] Added {totalEventCount} native objects from EVENTCON.MACHIDAT.");
    }

    // ─── Helpers ────────────────────────────────────────────────────────────────

    private static string GetObjectTypeLabel(byte otyp) => otyp switch
    {
        1 => "NPC",
        2 => "Prop",
        3 => "Chest",
        4 => "Trigger",
        _ => $"Type{otyp}"
    };

    private static string TryExtractDialogText(Component component)
    {
        try
        {
            var type = component.GetType();

            var fields = type.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);
            foreach (var field in fields)
            {
                string fieldName = field.Name.ToLower();
                if (fieldName.Contains("text") || fieldName.Contains("dialog") ||
                    fieldName.Contains("message") || fieldName.Contains("remark") ||
                    fieldName.Contains("messageid") || fieldName.Contains("msg"))
                {
                    var value = field.GetValue(component);
                    if (value is string s && !string.IsNullOrEmpty(s)) return s;
                    if (value is int intVal && intVal > 0) return $"[MessageID: {intVal}]";
                }
            }

            var props = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
            foreach (var prop in props)
            {
                string propName = prop.Name.ToLower();
                if (propName.Contains("text") || propName.Contains("dialog") ||
                    propName.Contains("message") || propName.Contains("msg"))
                {
                    if (!prop.CanRead) continue;
                    var value = prop.GetValue(component);
                    if (value is string s && !string.IsNullOrEmpty(s)) return s;
                    if (value is int intVal && intVal > 0) return $"[MessageID: {intVal}]";
                }
            }
        }
        catch { /* Ignore reflection errors */ }

        return null;
    }

    private static Transform FindObjectFolder(Transform parent)
    {
        if (parent.name == "object") return parent;
        for (int i = 0; i < parent.childCount; i++)
        {
            var result = FindObjectFolder(parent.GetChild(i));
            if (result != null) return result;
        }
        return null;
    }

    private static void SaveDiscoveredObjects()
    {
        try
        {
            string outputPath = Path.Combine(BepInEx.Paths.GameRootPath, "PKCore", "CustomObjects", "ExistingMapObjects.json");
            string directory = Path.GetDirectoryName(outputPath);
            if (!Directory.Exists(directory))
                Directory.CreateDirectory(directory);

            var options = new JsonSerializerOptions { WriteIndented = true };
            string json = JsonSerializer.Serialize(_discoveredObjects, options);
            File.WriteAllText(outputPath, json);

            Plugin.Log.LogInfo($"[ObjectDiscovery] Saved discovered objects to {outputPath}");
        }
        catch (Exception ex)
        {
            Plugin.Log.LogError($"[ObjectDiscovery] Error saving discovered objects: {ex}");
        }
    }
}

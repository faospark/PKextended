using HarmonyLib;
using UnityEngine;
using System.Collections.Generic;

namespace PKCore.Patches;

/// <summary>
/// Patches for Material.mainTexture replacement - handles ALL material texture setters
/// Provides comprehensive DDS and standard texture support for any material
/// </summary>
public partial class CustomTexturePatch
{
    // Track logged materials to prevent duplicate logging
    private static readonly HashSet<string> loggedMaterials = new HashSet<string>();

    /// <summary>
    /// Intercept Material.mainTexture setter to replace textures for all materials
    /// HIGH PRIORITY to run before summon-specific patches
    /// </summary>
    [HarmonyPatch(typeof(Material), nameof(Material.mainTexture), MethodType.Setter)]
    [HarmonyPrefix, HarmonyPriority(Priority.High)]
    public static void Material_set_mainTexture_General_Prefix(Material __instance, ref Texture value)
    {
        if (value == null || !Plugin.Config.EnableCustomTextures.Value)
            return;

        string textureName = value.name;
        if (string.IsNullOrEmpty(textureName))
            return;

        // DEBUG: Log material texture assignments only once and only when detailed logs are enabled
        if (Plugin.Config.DetailedTextureLog.Value)
        {
            string materialKey = $"{__instance.name}:{textureName}";
            if (loggedMaterials.Add(materialKey))
            {
                Plugin.Log.LogInfo($"[Material Debug] Setting mainTexture: {textureName} on material: {__instance.name}");
            }
        }

        // Skip if already processed or modified
        if (textureName.EndsWith("_Custom"))
            return;

        // Try to replace with custom texture reference
        if (value is Texture2D texture2D)
        {
            // Do NOT use ReplaceTextureInPlace here. 
            // Modifying the texture in-place crashes the game if that texture is also used by a Sprite (Mesh.uv out of bounds).
            // Instead, we just swap the reference on the material to a new texture.
            
            Texture2D customTexture = LoadCustomTexture(textureName);
            if (customTexture != null && customTexture != texture2D)
            {
                value = customTexture;
                if (Plugin.Config.DetailedTextureLog.Value)
                {
                    Plugin.Log.LogInfo($"[Material] Replaced mainTexture: {textureName} ({customTexture.format})");
                }
            }
        }
    }

    /// <summary>
    /// Intercept Material.mainTexture getter to catch textures loaded before our patches
    /// </summary>
    [HarmonyPatch(typeof(Material), nameof(Material.mainTexture), MethodType.Getter)]
    [HarmonyPostfix]
    public static void Material_get_mainTexture_General_Postfix(Material __instance, ref Texture __result)
    {
        if (__result == null || !Plugin.Config.EnableCustomTextures.Value)
            return;

        string textureName = __result.name;
        if (string.IsNullOrEmpty(textureName) || textureName.EndsWith("_Custom"))
            return;

        // Try to replace if we have a custom version
        if (__result is Texture2D texture2D)
        {
            // Do NOT use ReplaceTextureInPlace here (causes Mesh.uv errors)
            
            // Load custom texture
            Texture2D customTexture = LoadCustomTexture(textureName);
            if (customTexture != null && customTexture != texture2D)
            {
                __result = customTexture;
                __instance.mainTexture = customTexture; // Update the material too
                if (Plugin.Config.DetailedTextureLog.Value)
                {
                    Plugin.Log.LogInfo($"[Material Get] Replaced texture: {textureName} ({customTexture.format})");
                }
            }
        }
    }
}